{"ast":null,"code":"import { resolveComponent as _resolveComponent, createVNode as _createVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_PVDefenseur = _resolveComponent(\"PVDefenseur\");\n  return _openBlock(), _createElementBlock(\"div\", null, [_createVNode(_component_PVDefenseur, {\n    pv: _ctx.PV,\n    onDecrementPv: $options.perdrePvAttaquant\n  }, null, 8, [\"pv\", \"onDecrementPv\"])]);\n}","map":{"version":3,"names":["_createElementBlock","_createVNode","_component_PVDefenseur","pv","_ctx","PV","onDecrementPv","$options","perdrePvAttaquant"],"sources":["C:\\Users\\courluc\\IdeaProjects\\2024-NPA-PO-Hackstone\\src\\components\\plateauAttaque\\fonctionnaliteesAttaque.vue"],"sourcesContent":["<template>\r\n  <div>\r\n    <PVDefenseur :pv=\"PV\" @decrementPv=\"perdrePvAttaquant\" />\r\n  </div>\r\n</template>\r\n<script>\r\n//import PVDefenseur from \"@/components/plateauAttaque/PVDefenseur_attaque.vue\";\r\nimport { ref } from \"vue\";\r\n// Initialisation de la variable réactive PV (points de vie)\r\nlet PV = ref(5);\r\n// Importation du fichier JSON des CARTES\r\nlet carteEnJeu = [];\r\nlet pvAnonymous = 2;\r\nlet pvSuperAntivirus = 2;\r\nlet cardsData = require('../../../cards.json');\r\nlet dejaPosee = false;\r\nexport let cartesAttaque = [];\r\nconst DECK = {\r\n  cardsData\r\n};\r\nconst CARTES = DECK.cardsData.cards;\r\nexport default {\r\n\r\n  methods: {\r\n    /**\r\n     * Génère le deck du défenseur à partir d'un fichier json\r\n     * @returns cartesAttaque cartes présentent dans le deck\r\n     */\r\n    genererDeckDefense() {\r\n      let cartesAttaque = [];\r\n      for (let i = 0; i < CARTES.length; i++) {\r\n        if (CARTES[i].type === 'défense') {\r\n          //Retrouve le nombre de fois qu'une carte est présente dans le deck grâce à son nombre d'ID\r\n          for (let j = 0; j < CARTES[i].uid.length; j++)\r\n            cartesAttaque.push(CARTES[i]);\r\n        }\r\n      }\r\n      return cartesAttaque;\r\n    },\r\n\r\n    /**\r\n     * Génération d'un nombre entier aléatoire\r\n     * @param min fourchette minimale\r\n     * @param max fourchette maximale\r\n     * @returns {*} nombre entier aléatoire\r\n     */\r\n    getNombreAleatoire(min, max) {\r\n      return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    },\r\n\r\n    /**\r\n     * Pioche 5 cartes au hasard, si l'ordinateur possède déjà 5 cartes dans sa main, en pioche une seule,\r\n     * ensuite retire les cartes piochées du deck\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMain cartes présentent dans la main de l'ordinateur\r\n     */\r\n    piocher(cartesDeck, cartesEnMain) {\r\n      if (cartesEnMain.length >= 5) {\r\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\r\n        cartesEnMain.push(cartesDeck[index]);\r\n        cartesDeck.splice(index, 1);\r\n      }\r\n      while (cartesEnMain.length < 5) {\r\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\r\n        cartesEnMain.push(cartesDeck[index]);\r\n        cartesDeck.splice(index, 1);\r\n      }\r\n      cartesEnMain.splice(cartesEnMain.length, 1);\r\n    },\r\n\r\n    /**\r\n     * Effectue toutes les actions nécessaires au début de n'importe quel tour (excepté le premier)\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMains cartes présentent dans la main de l'ordinateur\r\n     */\r\n    DebutTour(cartesDeck, cartesEnMains) {\r\n      for (let i = 0; i < cartesDeck.length; i++) {\r\n        if (cartesDeck[i].name === (\"Stockage\")) {\r\n          cartesDeck.splice(i, 1);\r\n        }\r\n      }\r\n      this.piocher(cartesDeck, cartesEnMains);\r\n    },\r\n\r\n    /**\r\n     * Permet à l'ordinateur de remplir son terrain grâce aux cartes qu'il a dans sa main\r\n     * @param cartesEnMains carte dans la main de l'ordinateur\r\n     * @param reader lecteurs sur lesquels les cartes sont posées\r\n     */\r\n    poserCarte(cartesEnMains, reader) {\r\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\r\n      if (reader.image === null) {\r\n        let index = 0;\r\n        let cartePosee;\r\n\r\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\r\n        // afin qu'elle puisse copier une carte déjà présente\r\n        do {\r\n          index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\r\n          cartePosee = cartesEnMains[index];\r\n        } while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\r\n\r\n        //La carte redondance de données devient une copie de la carte sur la case de gauche.\r\n        if (cartePosee.name === \"Redondance de données\") {\r\n          alert(\"Redondance de données\");\r\n          cartePosee = carteEnJeu[0];\r\n        }\r\n\r\n        reader.image = cartePosee.image;\r\n        reader.name = cartePosee.name;\r\n        cartesEnMains.splice(index, 1);\r\n\r\n        carteEnJeu.push(cartePosee);\r\n      }\r\n    },\r\n\r\n    /**\r\n     *Permet à l'utilisateur d'attaquer les cartes de l'ordinateur,\r\n     * les attaques se font automatiquement sur la bonne carte\r\n     * @param card carte qui va attaquer\r\n     * @param readers lecteur sur lesquelles les cartes sont posées\r\n     */\r\n    attaquer(card, readers) {\r\n      let counterCarteEnJeu = [];\r\n      let carteDefendu = false;\r\n      let carteTrouvee = cartesAttaque.some(cartes => cartes.name === card.name);\r\n      let cartePresenteDepuis = cartesAttaque.find(carteATrouver => carteATrouver.name === card.name);\r\n      console.log(\"Carte trouvee\", carteTrouvee);\r\n      console.log(\"Carte attaque\", cartePresenteDepuis);\r\n      if (carteTrouvee && cartePresenteDepuis.poseeDepuis === 2) {\r\n        //Fonction permettant d'arrêter les deux boucles à un moment donné\r\n        outerLoop:\r\n            //Boucle passant sur chaque case de l'ordinateur\r\n            for (let j = 0; j < carteEnJeu.length; j++) {\r\n              //Liste des cartes qui contrent les cartes présentent sur le jeu\r\n              counterCarteEnJeu = carteEnJeu[j].counter;\r\n\r\n              //Boucle passant tous les contre des cartes\r\n              for (let i = 0; i < counterCarteEnJeu.length; i++) {\r\n                //Test si la carte qui attaque à un contre présent sur le terrain\r\n                if (counterCarteEnJeu.includes(card.name)) {\r\n                  carteDefendu = true;\r\n\r\n                  //Retrouve les cases sur lesquelles les cartes sont présentes\r\n                  let carte = readers.find(cartes => cartes.name === carteEnJeu[j].name);\r\n                  let carte2 = readers.find(zone => zone.name === card.name);\r\n\r\n                  //Retire le nom et l'image de la carte détruite de leur case\r\n                  //et détruit l'Anonymous et le super-antivirus uniquement s'ils ont déjà été attaqués une fois\r\n                  if ((carte.name === \"Super-antivirus\" && pvSuperAntivirus === 1) || carte.name !== \"Super-antivirus\") {\r\n                    carte.image = null;\r\n                    carte.name = null;\r\n                    carteEnJeu.splice(j, 1);\r\n                  } else\r\n                    pvSuperAntivirus = 1;\r\n\r\n                  if ((carte2.name === \"Anonymous\" && pvAnonymous === 1) || carte2.name !== \"Anonymous\") {\r\n                    carte2.image = null;\r\n                    carte2.name = null;\r\n                    cartesAttaque.splice(cartesAttaque.indexOf(carteTrouvee), 1);\r\n                  } else\r\n                    pvAnonymous = 1;\r\n\r\n                  //Termine la fonction une fois qu'une carte a été détruite\r\n                  break outerLoop;\r\n                }\r\n              }\r\n            }\r\n        if (PV.value === 0) {\r\n          alert(\"Bravo\")\r\n        }\r\n      } else if (!carteTrouvee) {\r\n        alert(\"Carte pas présente\")\r\n      } else {\r\n        alert(\"Vous devez attendre un tour avant de pouvoir attaquer avec cette carte !\")\r\n      }\r\n      if (!carteDefendu) {\r\n        console.log(\"carte pas defendue\")\r\n        this.perdrePvAttaquant();\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Retire toutes les cartes en défense lors de l'arrivée de l'anonymous\r\n     * @param card carte scannée\r\n     * @param reader liste des cases\r\n     */\r\n    arriveeAnonymous(card, reader) {\r\n      //Vérifie si la carte est bel et bien l'anonymous et qu'elle n'a pas déjà été posée\r\n      if (card.name === \"Anonymous\" && !dejaPosee) {\r\n        dejaPosee = true;\r\n        //Vide les cases\r\n        reader[0].name = null;\r\n        reader[0].image = null;\r\n        reader[1].name = null;\r\n        reader[1].image = null;\r\n        reader[4].name = null;\r\n        reader[4].image = null;\r\n\r\n        //Vide la liste des cartes en jeu, car plus aucune n'est présente\r\n        carteEnJeu = [];\r\n      }\r\n    },\r\n    defendMalin(cartesEnMains, reader) {\r\n\r\n      let test = [];\r\n      for (let a = 0; a < cartesAttaque.length; a++)\r\n        test.push(cartesAttaque[a]);\r\n      console.log(\"Test \", test)\r\n\r\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\r\n      if (reader.image === null) {\r\n        let index = 0;\r\n        let cartePosee = null;\r\n        console.log(\"Cartes en main\", cartesEnMains)\r\n        console.log(\"Cartes en jeu\", carteEnJeu)\r\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\r\n        // afin qu'elle puisse copier une carte déjà présente\r\n        outerLoop:\r\n            for (let i = 0; i < test.length; i++) {\r\n              for (let j = 0; j < cartesEnMains.length; j++) {\r\n                let carteEnMainCounter = cartesEnMains[j].counter;\r\n                //console.log(\"les counter\", carteEnMainCounter)\r\n                if (carteEnMainCounter.includes(test[i].name)) {\r\n                  cartePosee = cartesEnMains[j];\r\n                  reader.image = cartePosee.image;\r\n                  reader.name = cartePosee.name;\r\n                  cartesEnMains.splice(j, 1);\r\n                  carteEnJeu.push(cartePosee);\r\n                  test = [];\r\n                  break outerLoop;\r\n                }\r\n              }\r\n            }\r\n        if (cartePosee === null) {\r\n          do {\r\n            index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\r\n            cartePosee = cartesEnMains[index];\r\n          } while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\r\n\r\n          //La carte redondance de données devient une copie de la carte sur la case de gauche.\r\n          if (cartePosee.name === \"Redondance de données\") {\r\n            alert(\"Redondance de données\");\r\n            cartePosee = carteEnJeu[0];\r\n          }\r\n          reader.image = cartePosee.image;\r\n          reader.name = cartePosee.name;\r\n          cartesEnMains.splice(index, 1);\r\n\r\n          carteEnJeu.push(cartePosee);\r\n        }\r\n      }\r\n    },\r\n    // Gère la perte de PV de l'attaquant\r\n    perdrePvAttaquant() {\r\n      if (PV.value > 0) {\r\n        PV.value--;  // Décrémente la valeur de pv\r\n        console.log(\"PV restants :\", PV.value);\r\n      }\r\n      if (PV.value === 0) {\r\n        alert(\"Bravo, vous avez gagné !\");\r\n      }\r\n    }\r\n  }\r\n};\r\n</script>"],"mappings":";;;uBACEA,mBAAA,CAEM,cADJC,YAAA,CAAyDC,sBAAA;IAA3CC,EAAE,EAAEC,IAAA,CAAAC,EAAE;IAAGC,aAAW,EAAEC,QAAA,CAAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}