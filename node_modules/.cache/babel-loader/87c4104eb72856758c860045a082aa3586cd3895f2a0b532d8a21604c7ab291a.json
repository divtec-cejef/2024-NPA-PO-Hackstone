{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Importation du fichier JSON des CARTES\nlet carteEnJeu = [];\nlet pv = 5;\nlet pvAnonymous = 2;\nlet pvSuperAntivirus = 2;\nlet cardsData = require('../../../cards.json');\nlet dejaPosee = false;\nexport let cartesAttaque = [];\nconst DECK = {\n  cardsData\n};\nconst CARTES = DECK.cardsData.cards;\nexport default {\n  methods: {\n    /**\r\n     * Génère le deck du défenseur à partir d'un fichier json\r\n     * @returns cartesAttaque cartes présentent dans le deck\r\n     */\n    genererDeckDefense() {\n      let cartesAttaque = [];\n      for (let i = 0; i < CARTES.length; i++) {\n        if (CARTES[i].type === 'défense') {\n          //Retrouve le nombre de fois qu'une carte est présente dans le deck grâce à son nombre d'ID\n          for (let j = 0; j < CARTES[i].uid.length; j++) cartesAttaque.push(CARTES[i]);\n        }\n      }\n      return cartesAttaque;\n    },\n    /**\r\n     * Génération d'un nombre entier aléatoire\r\n     * @param min fourchette minimale\r\n     * @param max fourchette maximale\r\n     * @returns {*} nombre entier aléatoire\r\n     */\n    getNombreAleatoire(min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    },\n    /**\r\n     * Pioche 5 cartes au hasard, si l'ordinateur possède déjà 5 cartes dans sa main, en pioche une seule,\r\n     * ensuite retire les cartes piochées du deck\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMain cartes présentent dans la main de l'ordinateur\r\n     */\n    piocher(cartesDeck, cartesEnMain) {\n      if (cartesEnMain.length >= 5) {\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\n        cartesEnMain.push(cartesDeck[index]);\n        cartesDeck.splice(index, 1);\n      }\n      while (cartesEnMain.length < 5) {\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\n        cartesEnMain.push(cartesDeck[index]);\n        cartesDeck.splice(index, 1);\n      }\n      cartesEnMain.splice(cartesEnMain.length, 1);\n    },\n    /**\r\n     * Effectue toutes les actions nécessaires au début de n'importe quel tour (excepté le premier)\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMains cartes présentent dans la main de l'ordinateur\r\n     */\n    DebutTour(cartesDeck, cartesEnMains) {\n      for (let i = 0; i < cartesDeck.length; i++) {\n        if (cartesDeck[i].name === \"Stockage\") {\n          cartesDeck.splice(i, 1);\n        }\n      }\n      this.piocher(cartesDeck, cartesEnMains);\n    },\n    /**\r\n     * Permet à l'ordinateur de remplir son terrain grâce aux cartes qu'il a dans sa main\r\n     * @param cartesEnMains carte dans la main de l'ordinateur\r\n     * @param reader lecteurs sur lesquels les cartes sont posées\r\n     */\n    poserCarte(cartesEnMains, reader) {\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\n      if (reader.image === null) {\n        let index = 0;\n        let cartePosee;\n\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\n        // afin qu'elle puisse copier une carte déjà présente\n        do {\n          index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\n          cartePosee = cartesEnMains[index];\n        } while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\n\n        //La carte redondance de données devient une copie de la carte sur la case de gauche.\n        if (cartePosee.name === \"Redondance de données\") {\n          alert(\"Redondance de données\");\n          cartePosee = carteEnJeu[0];\n        }\n        reader.image = cartePosee.image;\n        reader.name = cartePosee.name;\n        cartesEnMains.splice(index, 1);\n        carteEnJeu.push(cartePosee);\n      }\n    },\n    /**\r\n     *Permet à l'utilisateur d'attaquer les cartes de l'ordinateur,\r\n     * les attaques se font automatiquement sur la bonne carte\r\n     * @param card carte qui va attaquer\r\n     * @param readers lecteur sur lesquelles les cartes sont posées\r\n     */\n    attaquer(card, readers) {\n      let counterCarteEnJeu = [];\n      let carteDefendu = false;\n      //Fonction permettant d'arrêter les deux boucles à un moment donné\n      outerLoop:\n      //Boucle passant sur chaque case de l'ordinateur\n      for (let j = 0; j < carteEnJeu.length; j++) {\n        //Liste des cartes qui contrent les cartes présentent sur le jeu\n        counterCarteEnJeu = carteEnJeu[j].counter;\n\n        //Boucle passant tous les contre des cartes\n        for (let i = 0; i < counterCarteEnJeu.length; i++) {\n          //Test si la carte qui attaque à un contre présent sur le terrain\n          if (counterCarteEnJeu.includes(card.name)) {\n            carteDefendu = true;\n\n            //Retrouve les cases sur lesquelles les cartes sont présentes\n            let carte = readers.find(cartes => cartes.name === carteEnJeu[j].name);\n            let carte2 = readers.find(zone => zone.name === card.name);\n\n            //Retire le nom et l'image de la carte détruite de leur case\n            //et détruit l'Anonymous et le super-antivirus uniquement s'ils ont déjà été attaqués une fois\n            if (carte.name === \"Super-antivirus\" && pvSuperAntivirus === 1 || carte.name !== \"Super-antivirus\") {\n              carte.image = null;\n              carte.name = null;\n              carteEnJeu.splice(j, 1);\n            } else pvSuperAntivirus = 1;\n            if (carte2.name === \"Anonymous\" && pvAnonymous === 1 || carte2.name !== \"Anonymous\") {\n              carte2.image = null;\n              carte2.name = null;\n            } else pvAnonymous = 1;\n\n            //Termine la fonction une fois qu'une carte a été détruite\n            break outerLoop;\n          }\n        }\n      }\n      if (!carteDefendu) {\n        pv--;\n        alert(pv);\n      }\n      if (pv === 0) {\n        alert(\"Bravo\");\n      }\n    },\n    /**\r\n     * Retire toutes les cartes en défense lors de l'arrivée de l'anonymous\r\n     * @param card carte scannée\r\n     * @param reader liste des cases\r\n     */\n    arriveeAnonymous(card, reader) {\n      //Vérifie si la carte est bel et bien l'anonymous et qu'elle n'a pas déjà été posée\n      if (card.name === \"Anonymous\" && !dejaPosee) {\n        dejaPosee = true;\n        //Vide les cases\n        reader[0].name = null;\n        reader[0].image = null;\n        reader[1].name = null;\n        reader[1].image = null;\n        reader[4].name = null;\n        reader[4].image = null;\n\n        //Vide la liste des cartes en jeu, car plus aucune n'est présente\n        carteEnJeu = [];\n      }\n    },\n    defendMalin(cartesEnMains, reader) {\n      console.log(\"Cartes en attaque\", cartesAttaque);\n      let test = cartesAttaque;\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\n      if (reader.image === null) {\n        let index = 0;\n        let cartePosee = null;\n        console.log(\"Cartes en main\", cartesEnMains);\n        console.log(\"Cartes en jeu\", carteEnJeu);\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\n        // afin qu'elle puisse copier une carte déjà présente\n        for (let i = 0; i < test.length; i++) {\n          for (let j = 0; j < cartesEnMains.length; j++) {\n            let carteEnMainCounter = cartesEnMains[j].counter;\n            if (carteEnMainCounter.includes(test[i])) {\n              console.log(\"Ici\", cartesEnMains[j]);\n              console.log(\"la\", test[i]);\n              cartePosee = cartesEnMains[j];\n              reader.image = cartePosee.image;\n              reader.name = cartePosee.name;\n              cartesEnMains.splice(j, 1);\n              carteEnJeu.push(cartePosee);\n              test.splice(i, 1);\n            }\n          }\n        }\n        if (cartePosee === null) {\n          do {\n            index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\n            cartePosee = cartesEnMains[index];\n          } while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\n\n          //La carte redondance de données devient une copie de la carte sur la case de gauche.\n          if (cartePosee.name === \"Redondance de données\") {\n            alert(\"Redondance de données\");\n            cartePosee = carteEnJeu[0];\n          }\n          reader.image = cartePosee.image;\n          reader.name = cartePosee.name;\n          cartesEnMains.splice(index, 1);\n          carteEnJeu.push(cartePosee);\n        }\n      }\n    }\n  }\n};","map":{"version":3,"names":["carteEnJeu","pv","pvAnonymous","pvSuperAntivirus","cardsData","require","dejaPosee","cartesAttaque","DECK","CARTES","cards","methods","genererDeckDefense","i","length","type","j","uid","push","getNombreAleatoire","min","max","Math","floor","random","piocher","cartesDeck","cartesEnMain","index","splice","DebutTour","cartesEnMains","name","poserCarte","reader","image","cartePosee","alert","attaquer","card","readers","counterCarteEnJeu","carteDefendu","outerLoop","counter","includes","carte","find","cartes","carte2","zone","arriveeAnonymous","defendMalin","console","log","test","carteEnMainCounter"],"sources":["C:\\Users\\courluc\\IdeaProjects\\2024-NPA-PO-Hackstone\\src\\components\\plateauAttaque\\fonctionnaliteesAttaque.vue"],"sourcesContent":["<script>\r\n// Importation du fichier JSON des CARTES\r\nlet carteEnJeu = [];\r\nlet pv = 5;\r\nlet pvAnonymous = 2;\r\nlet pvSuperAntivirus = 2;\r\nlet cardsData = require('../../../cards.json');\r\nlet dejaPosee = false;\r\nexport let cartesAttaque = [];\r\nconst DECK = {\r\n  cardsData\r\n};\r\nconst CARTES = DECK.cardsData.cards;\r\nexport default {\r\n\r\n  methods: {\r\n    /**\r\n     * Génère le deck du défenseur à partir d'un fichier json\r\n     * @returns cartesAttaque cartes présentent dans le deck\r\n     */\r\n    genererDeckDefense() {\r\n      let cartesAttaque = [];\r\n      for (let i = 0; i < CARTES.length; i++) {\r\n        if (CARTES[i].type === 'défense') {\r\n          //Retrouve le nombre de fois qu'une carte est présente dans le deck grâce à son nombre d'ID\r\n          for (let j = 0; j < CARTES[i].uid.length; j++)\r\n            cartesAttaque.push(CARTES[i]);\r\n        }\r\n      }\r\n      return cartesAttaque;\r\n    },\r\n\r\n    /**\r\n     * Génération d'un nombre entier aléatoire\r\n     * @param min fourchette minimale\r\n     * @param max fourchette maximale\r\n     * @returns {*} nombre entier aléatoire\r\n     */\r\n    getNombreAleatoire(min, max) {\r\n      return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    },\r\n\r\n    /**\r\n     * Pioche 5 cartes au hasard, si l'ordinateur possède déjà 5 cartes dans sa main, en pioche une seule,\r\n     * ensuite retire les cartes piochées du deck\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMain cartes présentent dans la main de l'ordinateur\r\n     */\r\n    piocher(cartesDeck, cartesEnMain) {\r\n      if (cartesEnMain.length >= 5) {\r\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\r\n        cartesEnMain.push(cartesDeck[index]);\r\n        cartesDeck.splice(index, 1);\r\n      }\r\n      while (cartesEnMain.length < 5) {\r\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\r\n        cartesEnMain.push(cartesDeck[index]);\r\n        cartesDeck.splice(index, 1);\r\n      }\r\n      cartesEnMain.splice(cartesEnMain.length, 1);\r\n    },\r\n\r\n    /**\r\n     * Effectue toutes les actions nécessaires au début de n'importe quel tour (excepté le premier)\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMains cartes présentent dans la main de l'ordinateur\r\n     */\r\n    DebutTour(cartesDeck, cartesEnMains) {\r\n      for (let i = 0; i < cartesDeck.length; i++){\r\n        if (cartesDeck[i].name === (\"Stockage\")){\r\n          cartesDeck.splice(i, 1);\r\n        }\r\n      }\r\n      this.piocher(cartesDeck, cartesEnMains);\r\n    },\r\n\r\n    /**\r\n     * Permet à l'ordinateur de remplir son terrain grâce aux cartes qu'il a dans sa main\r\n     * @param cartesEnMains carte dans la main de l'ordinateur\r\n     * @param reader lecteurs sur lesquels les cartes sont posées\r\n     */\r\n    poserCarte(cartesEnMains, reader) {\r\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\r\n      if (reader.image === null) {\r\n        let index = 0;\r\n        let cartePosee;\r\n\r\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\r\n        // afin qu'elle puisse copier une carte déjà présente\r\n        do {\r\n          index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\r\n          cartePosee = cartesEnMains[index];\r\n        }while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\r\n\r\n        //La carte redondance de données devient une copie de la carte sur la case de gauche.\r\n        if(cartePosee.name === \"Redondance de données\") {\r\n          alert(\"Redondance de données\");\r\n          cartePosee = carteEnJeu[0];\r\n        }\r\n\r\n        reader.image = cartePosee.image;\r\n        reader.name = cartePosee.name;\r\n        cartesEnMains.splice(index, 1);\r\n\r\n        carteEnJeu.push(cartePosee);\r\n      }\r\n    },\r\n\r\n    /**\r\n     *Permet à l'utilisateur d'attaquer les cartes de l'ordinateur,\r\n     * les attaques se font automatiquement sur la bonne carte\r\n     * @param card carte qui va attaquer\r\n     * @param readers lecteur sur lesquelles les cartes sont posées\r\n     */\r\n    attaquer(card, readers) {\r\n      let counterCarteEnJeu = [];\r\n      let carteDefendu = false;\r\n      //Fonction permettant d'arrêter les deux boucles à un moment donné\r\n      outerLoop:\r\n          //Boucle passant sur chaque case de l'ordinateur\r\n          for (let j = 0; j < carteEnJeu.length; j++) {\r\n            //Liste des cartes qui contrent les cartes présentent sur le jeu\r\n            counterCarteEnJeu = carteEnJeu[j].counter;\r\n\r\n            //Boucle passant tous les contre des cartes\r\n            for (let i = 0; i < counterCarteEnJeu.length; i++) {\r\n              //Test si la carte qui attaque à un contre présent sur le terrain\r\n              if (counterCarteEnJeu.includes(card.name)) {\r\n                carteDefendu = true;\r\n\r\n                //Retrouve les cases sur lesquelles les cartes sont présentes\r\n                let carte = readers.find(cartes => cartes.name === carteEnJeu[j].name);\r\n                let carte2 = readers.find(zone => zone.name === card.name);\r\n\r\n                //Retire le nom et l'image de la carte détruite de leur case\r\n                //et détruit l'Anonymous et le super-antivirus uniquement s'ils ont déjà été attaqués une fois\r\n                if ((carte.name === \"Super-antivirus\" && pvSuperAntivirus === 1) || carte.name !== \"Super-antivirus\") {\r\n                  carte.image = null;\r\n                  carte.name = null;\r\n                  carteEnJeu.splice(j, 1);\r\n                } else\r\n                  pvSuperAntivirus = 1;\r\n\r\n                if ((carte2.name === \"Anonymous\" && pvAnonymous === 1) || carte2.name !== \"Anonymous\") {\r\n                  carte2.image = null;\r\n                  carte2.name = null;\r\n                } else\r\n                  pvAnonymous = 1;\r\n\r\n                //Termine la fonction une fois qu'une carte a été détruite\r\n                break outerLoop;\r\n              }\r\n            }\r\n          }\r\n      if (!carteDefendu) {\r\n        pv--;\r\n        alert(pv);\r\n      }\r\n      if (pv === 0){\r\n        alert(\"Bravo\")\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Retire toutes les cartes en défense lors de l'arrivée de l'anonymous\r\n     * @param card carte scannée\r\n     * @param reader liste des cases\r\n     */\r\n    arriveeAnonymous(card, reader) {\r\n      //Vérifie si la carte est bel et bien l'anonymous et qu'elle n'a pas déjà été posée\r\n      if(card.name === \"Anonymous\" && !dejaPosee) {\r\n        dejaPosee = true;\r\n        //Vide les cases\r\n        reader[0].name = null;\r\n        reader[0].image = null;\r\n        reader[1].name = null;\r\n        reader[1].image = null;\r\n        reader[4].name = null;\r\n        reader[4].image = null;\r\n\r\n        //Vide la liste des cartes en jeu, car plus aucune n'est présente\r\n        carteEnJeu = [];\r\n      }\r\n    },\r\n    defendMalin(cartesEnMains, reader) {\r\n      console.log(\"Cartes en attaque\", cartesAttaque);\r\n      let test = cartesAttaque;\r\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\r\n      if (reader.image === null) {\r\n        let index = 0;\r\n        let cartePosee = null;\r\n        console.log(\"Cartes en main\", cartesEnMains)\r\n        console.log(\"Cartes en jeu\", carteEnJeu)\r\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\r\n        // afin qu'elle puisse copier une carte déjà présente\r\n        for (let i = 0; i < test.length; i++) {\r\n          for (let j = 0; j < cartesEnMains.length; j++) {\r\n            let carteEnMainCounter = cartesEnMains[j].counter;\r\n            if (carteEnMainCounter.includes(test[i])) {\r\n              console.log(\"Ici\", cartesEnMains[j]);\r\n              console.log(\"la\", test[i]);\r\n              cartePosee = cartesEnMains[j];\r\n              reader.image = cartePosee.image;\r\n              reader.name = cartePosee.name;\r\n              cartesEnMains.splice(j, 1);\r\n              carteEnJeu.push(cartePosee);\r\n              test.splice(i, 1);\r\n            }\r\n          }\r\n        }\r\n        if (cartePosee === null) {\r\n          do {\r\n            index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\r\n            cartePosee = cartesEnMains[index];\r\n          } while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\r\n\r\n          //La carte redondance de données devient une copie de la carte sur la case de gauche.\r\n          if (cartePosee.name === \"Redondance de données\") {\r\n            alert(\"Redondance de données\");\r\n            cartePosee = carteEnJeu[0];\r\n          }\r\n\r\n          reader.image = cartePosee.image;\r\n          reader.name = cartePosee.name;\r\n          cartesEnMains.splice(index, 1);\r\n\r\n          carteEnJeu.push(cartePosee);\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\r\n</script>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}