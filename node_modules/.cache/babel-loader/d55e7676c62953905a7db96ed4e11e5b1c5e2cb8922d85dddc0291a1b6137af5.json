{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref } from \"vue\"; // Importation de `ref` pour créer des variables réactives\nexport let pv = ref(5);\n\n// Importation du fichier JSON des CARTES\nlet cardsData = require('../../../cards.json');\nlet carteEnJeu = [];\nlet pvAnonymous = 2;\nlet pvSuperAntivirus = 2;\nlet nbrAttaqueAnonymous = 0;\nlet dejaPosee = false;\nexport let dejaAttaquer = [];\nexport let cartesAttaque = [];\nconst DECK = {\n  cardsData\n};\nconst CARTES = DECK.cardsData.cards;\nexport default {\n  methods: {\n    /**\r\n     * Génère le deck du défenseur à partir d'un fichier json\r\n     * @returns cartesAttaque cartes présentent dans le deck\r\n     */\n    genererDeckDefense() {\n      let cartesAttaque = [];\n      for (let i = 0; i < CARTES.length; i++) {\n        if (CARTES[i].type === 'défense') {\n          //Retrouve le nombre de fois qu'une carte est présente dans le deck grâce à son nombre d'ID\n          for (let j = 0; j < CARTES[i].uid.length; j++) cartesAttaque.push(CARTES[i]);\n        }\n      }\n      return cartesAttaque;\n    },\n    /**\r\n     * Génération d'un nombre entier aléatoire\r\n     * @param min fourchette minimale\r\n     * @param max fourchette maximale\r\n     * @returns {*} nombre entier aléatoire\r\n     */\n    getNombreAleatoire(min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    },\n    /**\r\n     * Pioche 5 cartes au hasard, si l'ordinateur possède déjà 5 cartes dans sa main, en pioche une seule,\r\n     * ensuite retire les cartes piochées du deck\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMain cartes présentent dans la main de l'ordinateur\r\n     */\n    piocher(cartesDeck, cartesEnMain) {\n      if (cartesEnMain.length >= 5) {\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\n        cartesEnMain.push(cartesDeck[index]);\n        cartesDeck.splice(index, 1);\n      }\n      while (cartesEnMain.length < 5) {\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\n        cartesEnMain.push(cartesDeck[index]);\n        cartesDeck.splice(index, 1);\n      }\n      cartesEnMain.splice(cartesEnMain.length, 1);\n    },\n    /**\r\n     * Effectue toutes les actions nécessaires au début de n'importe quel tour (excepté le premier)\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMains cartes présentent dans la main de l'ordinateur\r\n     */\n    DebutTour(cartesDeck, cartesEnMains) {\n      // for (let i = 0; i < cartesDeck.length; i++) {\n      //   // if (cartesDeck[i].name === (\"Stockage\")) {\n      //   //   cartesDeck.splice(i, 1);\n      //   // }\n      // }\n      this.piocher(cartesDeck, cartesEnMains);\n    },\n    /**\r\n     * Permet à l'ordinateur de remplir son terrain grâce aux cartes qu'il a dans sa main\r\n     * @param cartesEnMains carte dans la main de l'ordinateur\r\n     * @param reader lecteurs sur lesquels les cartes sont posées\r\n     */\n    poserCarte(cartesEnMains, reader) {\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\n      if (reader.image === null) {\n        let index = 0;\n        let cartePosee;\n\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\n        // afin qu'elle puisse copier une carte déjà présente\n        do {\n          index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\n          cartePosee = cartesEnMains[index];\n        } while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\n\n        //La carte redondance de données devient une copie de la carte sur la case de gauche.\n        if (cartePosee.name === \"Redondance de données\") {\n          alert(\"Redondance de données\");\n          cartePosee = carteEnJeu[0];\n        }\n        reader.image = cartePosee.image;\n        reader.name = cartePosee.name;\n        cartesEnMains.splice(index, 1);\n        carteEnJeu.push(cartePosee);\n      }\n    },\n    /**\r\n     *Permet à l'utilisateur d'attaquer les cartes de l'ordinateur,\r\n     * les attaques se font automatiquement sur la bonne carte\r\n     * @param card carte qui va attaquer\r\n     * @param readers lecteur sur lesquelles les cartes sont posées\r\n     */\n    attaquer(card, readers) {\n      let counterCarteEnJeu = [];\n      let carteDefendu = false;\n\n      //Recherche si la carte est bel et bien présente sur le jeu\n      let carteTrouvee = cartesAttaque.some(cartes => cartes.name === card.name);\n      //Retrouve la carte afin de savoir depuis quand elle est présente sur le jeu\n      let cartePresenteDepuis = this.trouverObjet(card, cartesAttaque);\n      //Retrouve si la carte a déjà attaqué ou non.\n      let carteDejaAttaquer = dejaAttaquer.some(carteAttaquante => carteAttaquante.name === card.name);\n      console.log(\"carte\", carteDejaAttaquer);\n      console.log(\"cartes en attaque \", cartesAttaque);\n      let indexx = this.trouverObjet(card, cartesAttaque);\n      let index = cartesAttaque.indexOf(indexx);\n      const occurrences = cartesAttaque.filter(c => c.name === card.name).length;\n      console.log(\"Carte trouvée\", carteTrouvee);\n      cartesAttaque.splice(index, 1);\n      //Test si la carte est présente, si elle ne vient pas d'être posée et si elle n'a pas déjà attaqué\n      if (carteTrouvee && cartePresenteDepuis.poseeDepuis === 2 && !carteDejaAttaquer) {\n        //Test si la carte qui attaque est présente plus d'une fois\n        if (occurrences === 1) {\n          if (card.name === \"Anonymous\") {\n            nbrAttaqueAnonymous++;\n            if (nbrAttaqueAnonymous >= 2) dejaAttaquer.push(card);\n          } else dejaAttaquer.push(card);\n        }\n        console.log(\"Deja attaquer\", dejaAttaquer);\n        //Fonction permettant d'arrêter les deux boucles à un moment donné\n        outerLoop:\n        //Boucle passant sur chaque case de l'ordinateur\n        for (let j = 0; j < carteEnJeu.length; j++) {\n          //Liste des cartes qui contrent les cartes présentent sur le jeu\n          counterCarteEnJeu = carteEnJeu[j].counter;\n\n          //Boucle passant tous les contre des cartes\n          for (let i = 0; i < counterCarteEnJeu.length; i++) {\n            //Test si la carte qui attaque à un contre présent sur le terrain\n            if (counterCarteEnJeu.includes(card.name)) {\n              carteDefendu = true;\n\n              //Retrouve les cases sur lesquelles les cartes sont présentes\n              let carte = this.trouverObjet(carteEnJeu[j], readers);\n              let carte2 = this.trouverObjet(card, readers);\n\n              //Retire le nom et l'image de la carte détruite de leur case\n              //et détruit l'Anonymous et le super-antivirus uniquement s'ils ont déjà été attaqués une fois\n              if (carte.name === \"Super-antivirus\" && pvSuperAntivirus === 1 || carte.name !== \"Super-antivirus\") {\n                carte.image = null;\n                carte.name = null;\n                carteEnJeu.splice(j, 1);\n              } else pvSuperAntivirus = 1;\n              if (carte2.name === \"Anonymous\" && pvAnonymous === 1 || carte2.name !== \"Anonymous\") {\n                carte2.image = null;\n                carte2.name = null;\n              } else pvAnonymous = 1;\n\n              //Termine la fonction une fois qu'une carte a été détruite\n              break outerLoop;\n            }\n          }\n        }\n        if (!carteDefendu) {\n          console.log(\"carte pas defendue\");\n          this.perdrePvAttaquant();\n          cartesAttaque.push(card);\n        }\n      } else if (!carteTrouvee) {\n        alert(\"Carte pas présente\");\n      } else if (carteDejaAttaquer) {\n        cartesAttaque.push(card);\n        alert(\"cette carte a deja attaquer\");\n      } else if (cartePresenteDepuis.poseeDepuis !== 2) {\n        cartesAttaque.push(card);\n        alert(\"Vous devez attendre un tour avant de pouvoir attaquer avec cette carte !\");\n      }\n      if (card.name === \"Anonymous\" && pvAnonymous > 0 && nbrAttaqueAnonymous < 2) {\n        card.poseeDepuis = 2;\n        cartesAttaque.push(card);\n      }\n    },\n    /**\r\n     * Retire toutes les cartes en défense lors de l'arrivée de l'anonymous\r\n     * @param card carte scannée\r\n     * @param reader liste des cases\r\n     */\n    arriveeAnonymous(card, reader) {\n      pvAnonymous = 2;\n      //Vérifie si la carte est bel et bien l'anonymous et qu'elle n'a pas déjà été posée\n      if (card.name === \"Anonymous\" && !dejaPosee) {\n        dejaPosee = true;\n        //Vide les cases\n        reader[0].name = null;\n        reader[0].image = null;\n        reader[1].name = null;\n        reader[1].image = null;\n        reader[4].name = null;\n        reader[4].image = null;\n\n        //Vide la liste des cartes en jeu, car plus aucune n'est présente\n        carteEnJeu = [];\n      }\n    },\n    defendMalin(cartesEnMains, reader) {\n      nbrAttaqueAnonymous = 0;\n      let test = [];\n      for (let a = 0; a < cartesAttaque.length; a++) test.push(cartesAttaque[a]);\n      console.log(\"Test \", test);\n\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\n      if (reader.image === null) {\n        let index = 0;\n        let cartePosee = null;\n        console.log(\"Cartes en main\", cartesEnMains);\n        console.log(\"Cartes en jeu\", carteEnJeu);\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\n        // afin qu'elle puisse copier une carte déjà présente\n\n        outerLoop: for (let i = 0; i < test.length; i++) {\n          for (let j = 0; j < cartesEnMains.length; j++) {\n            console.log(\"Je loupe ?\", j);\n            if (cartesEnMains[j].name === \"Stockage\") {\n              this.$refs.Case_4_Defenseur_Attaque.triggerLockAnimation();\n              cartePosee = cartesEnMains[j];\n              // this.ouvrirCadenas();\n              alert(\"Cadenas\");\n            } else {\n              console.log(\"Ici ca passe\");\n              let carteEnMainCounter = cartesEnMains[j].counter;\n              //console.log(\"les counter\", carteEnMainCounter)\n              if (carteEnMainCounter.includes(test[i].name)) {\n                console.log(\"Ici aussi\");\n                cartePosee = cartesEnMains[j];\n                if (cartePosee.name === \"Redondance de données\") {\n                  console.log(\"La aussi\");\n                  if (carteEnJeu.length === 0) {\n                    console.log(\"La pareil\");\n                    cartePosee = cartesEnMains[j + 1];\n                  } else {\n                    cartePosee = carteEnJeu[0];\n                    console.log(\"Ou est le probleme\");\n                  }\n                }\n              }\n            }\n            console.log(\"Defend malin\");\n            reader.image = cartePosee.image;\n            reader.name = cartePosee.name;\n            cartesEnMains.splice(j, 1);\n            carteEnJeu.push(cartePosee);\n            test = [];\n            break outerLoop;\n          }\n        }\n        if (cartePosee === null) {\n          do {\n            index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\n            cartePosee = cartesEnMains[index];\n          } while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\n\n          //La carte redondance de données devient une copie de la carte sur la case de gauche.\n          if (cartePosee.name === \"Redondance de données\") {\n            alert(\"Redondance de données\");\n            cartePosee = carteEnJeu[0];\n          }\n          reader.image = cartePosee.image;\n          reader.name = cartePosee.name;\n          cartesEnMains.splice(index, 1);\n          carteEnJeu.push(cartePosee);\n        }\n      }\n    },\n    // Gère la perte de PV de l'attaquant\n    perdrePvAttaquant() {\n      if (pv.value > 0) {\n        pv.value--; // Décrémentation de la valeur réactive de pv\n        console.log(\"pv\", pv.value);\n      }\n    },\n    resetDejaAttaquer() {\n      dejaAttaquer = [];\n    },\n    trouverObjet(card, liste) {\n      return liste.find(objet => objet.name === card.name);\n    },\n    trouverCarte() {\n      return true;\n    }\n  }\n};","map":{"version":3,"names":["ref","pv","cardsData","require","carteEnJeu","pvAnonymous","pvSuperAntivirus","nbrAttaqueAnonymous","dejaPosee","dejaAttaquer","cartesAttaque","DECK","CARTES","cards","methods","genererDeckDefense","i","length","type","j","uid","push","getNombreAleatoire","min","max","Math","floor","random","piocher","cartesDeck","cartesEnMain","index","splice","DebutTour","cartesEnMains","poserCarte","reader","image","cartePosee","name","alert","attaquer","card","readers","counterCarteEnJeu","carteDefendu","carteTrouvee","some","cartes","cartePresenteDepuis","trouverObjet","carteDejaAttaquer","carteAttaquante","console","log","indexx","indexOf","occurrences","filter","c","poseeDepuis","outerLoop","counter","includes","carte","carte2","perdrePvAttaquant","arriveeAnonymous","defendMalin","test","a","$refs","Case_4_Defenseur_Attaque","triggerLockAnimation","carteEnMainCounter","value","resetDejaAttaquer","liste","find","objet","trouverCarte"],"sources":["C:\\Users\\courluc\\IdeaProjects\\2024-NPA-PO-Hackstone\\src\\components\\plateauAttaque\\fonctionnaliteesAttaque.vue"],"sourcesContent":["<script>\r\nimport {ref} from \"vue\";// Importation de `ref` pour créer des variables réactives\r\nexport let pv = ref(5);\r\n\r\n// Importation du fichier JSON des CARTES\r\nlet cardsData = require('../../../cards.json');\r\nlet carteEnJeu = [];\r\nlet pvAnonymous = 2;\r\nlet pvSuperAntivirus = 2;\r\nlet nbrAttaqueAnonymous = 0;\r\nlet dejaPosee = false;\r\nexport let dejaAttaquer = [];\r\nexport let cartesAttaque = [];\r\nconst DECK = {\r\n  cardsData\r\n};\r\nconst CARTES = DECK.cardsData.cards;\r\nexport default {\r\n  methods: {\r\n    /**\r\n     * Génère le deck du défenseur à partir d'un fichier json\r\n     * @returns cartesAttaque cartes présentent dans le deck\r\n     */\r\n    genererDeckDefense() {\r\n      let cartesAttaque = [];\r\n      for (let i = 0; i < CARTES.length; i++) {\r\n        if (CARTES[i].type === 'défense') {\r\n          //Retrouve le nombre de fois qu'une carte est présente dans le deck grâce à son nombre d'ID\r\n          for (let j = 0; j < CARTES[i].uid.length; j++)\r\n            cartesAttaque.push(CARTES[i]);\r\n        }\r\n      }\r\n      return cartesAttaque;\r\n    },\r\n\r\n    /**\r\n     * Génération d'un nombre entier aléatoire\r\n     * @param min fourchette minimale\r\n     * @param max fourchette maximale\r\n     * @returns {*} nombre entier aléatoire\r\n     */\r\n    getNombreAleatoire(min, max) {\r\n      return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    },\r\n\r\n    /**\r\n     * Pioche 5 cartes au hasard, si l'ordinateur possède déjà 5 cartes dans sa main, en pioche une seule,\r\n     * ensuite retire les cartes piochées du deck\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMain cartes présentent dans la main de l'ordinateur\r\n     */\r\n    piocher(cartesDeck, cartesEnMain) {\r\n      if (cartesEnMain.length >= 5) {\r\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\r\n        cartesEnMain.push(cartesDeck[index]);\r\n        cartesDeck.splice(index, 1);\r\n      }\r\n      while (cartesEnMain.length < 5) {\r\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\r\n        cartesEnMain.push(cartesDeck[index]);\r\n        cartesDeck.splice(index, 1);\r\n      }\r\n      cartesEnMain.splice(cartesEnMain.length, 1);\r\n    },\r\n\r\n    /**\r\n     * Effectue toutes les actions nécessaires au début de n'importe quel tour (excepté le premier)\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMains cartes présentent dans la main de l'ordinateur\r\n     */\r\n    DebutTour(cartesDeck, cartesEnMains) {\r\n      // for (let i = 0; i < cartesDeck.length; i++) {\r\n      //   // if (cartesDeck[i].name === (\"Stockage\")) {\r\n      //   //   cartesDeck.splice(i, 1);\r\n      //   // }\r\n      // }\r\n      this.piocher(cartesDeck, cartesEnMains);\r\n    },\r\n\r\n    /**\r\n     * Permet à l'ordinateur de remplir son terrain grâce aux cartes qu'il a dans sa main\r\n     * @param cartesEnMains carte dans la main de l'ordinateur\r\n     * @param reader lecteurs sur lesquels les cartes sont posées\r\n     */\r\n    poserCarte(cartesEnMains, reader) {\r\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\r\n      if (reader.image === null) {\r\n        let index = 0;\r\n        let cartePosee;\r\n\r\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\r\n        // afin qu'elle puisse copier une carte déjà présente\r\n        do {\r\n          index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\r\n          cartePosee = cartesEnMains[index];\r\n        } while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\r\n\r\n        //La carte redondance de données devient une copie de la carte sur la case de gauche.\r\n        if (cartePosee.name === \"Redondance de données\") {\r\n          alert(\"Redondance de données\");\r\n          cartePosee = carteEnJeu[0];\r\n        }\r\n\r\n        reader.image = cartePosee.image;\r\n        reader.name = cartePosee.name;\r\n        cartesEnMains.splice(index, 1);\r\n\r\n        carteEnJeu.push(cartePosee);\r\n      }\r\n    },\r\n\r\n    /**\r\n     *Permet à l'utilisateur d'attaquer les cartes de l'ordinateur,\r\n     * les attaques se font automatiquement sur la bonne carte\r\n     * @param card carte qui va attaquer\r\n     * @param readers lecteur sur lesquelles les cartes sont posées\r\n     */\r\n    attaquer(card, readers) {\r\n\r\n      let counterCarteEnJeu = [];\r\n      let carteDefendu = false;\r\n\r\n      //Recherche si la carte est bel et bien présente sur le jeu\r\n      let carteTrouvee = cartesAttaque.some(cartes => cartes.name === card.name);\r\n      //Retrouve la carte afin de savoir depuis quand elle est présente sur le jeu\r\n      let cartePresenteDepuis = this.trouverObjet(card, cartesAttaque);\r\n      //Retrouve si la carte a déjà attaqué ou non.\r\n      let carteDejaAttaquer = dejaAttaquer.some(carteAttaquante => carteAttaquante.name === card.name);\r\n\r\n      console.log(\"carte\", carteDejaAttaquer);\r\n      console.log(\"cartes en attaque \", cartesAttaque);\r\n\r\n      let indexx = this.trouverObjet(card, cartesAttaque);\r\n      let index = cartesAttaque.indexOf(indexx);\r\n\r\n      const occurrences = cartesAttaque.filter(c => c.name === card.name).length;\r\n      console.log(\"Carte trouvée\", carteTrouvee);\r\n      cartesAttaque.splice(index, 1);\r\n      //Test si la carte est présente, si elle ne vient pas d'être posée et si elle n'a pas déjà attaqué\r\n      if (carteTrouvee && cartePresenteDepuis.poseeDepuis === 2 && !carteDejaAttaquer) {\r\n        //Test si la carte qui attaque est présente plus d'une fois\r\n        if (occurrences === 1) {\r\n          if (card.name === \"Anonymous\"){\r\n            nbrAttaqueAnonymous++;\r\n            if(nbrAttaqueAnonymous >= 2)\r\n              dejaAttaquer.push(card);\r\n          }else\r\n            dejaAttaquer.push(card);\r\n        }\r\n        console.log(\"Deja attaquer\", dejaAttaquer);\r\n        //Fonction permettant d'arrêter les deux boucles à un moment donné\r\n        outerLoop:\r\n            //Boucle passant sur chaque case de l'ordinateur\r\n            for (let j = 0; j < carteEnJeu.length; j++) {\r\n              //Liste des cartes qui contrent les cartes présentent sur le jeu\r\n              counterCarteEnJeu = carteEnJeu[j].counter;\r\n\r\n              //Boucle passant tous les contre des cartes\r\n              for (let i = 0; i < counterCarteEnJeu.length; i++) {\r\n                //Test si la carte qui attaque à un contre présent sur le terrain\r\n                if (counterCarteEnJeu.includes(card.name)) {\r\n                  carteDefendu = true;\r\n\r\n                  //Retrouve les cases sur lesquelles les cartes sont présentes\r\n                  let carte = this.trouverObjet(carteEnJeu[j], readers);\r\n                  let carte2 = this.trouverObjet(card, readers);\r\n\r\n                  //Retire le nom et l'image de la carte détruite de leur case\r\n                  //et détruit l'Anonymous et le super-antivirus uniquement s'ils ont déjà été attaqués une fois\r\n                  if ((carte.name === \"Super-antivirus\" && pvSuperAntivirus === 1) || carte.name !== \"Super-antivirus\") {\r\n                    carte.image = null;\r\n                    carte.name = null;\r\n                    carteEnJeu.splice(j, 1);\r\n                  } else\r\n                    pvSuperAntivirus = 1;\r\n\r\n                  if ((carte2.name === \"Anonymous\" && pvAnonymous === 1) || carte2.name !== \"Anonymous\") {\r\n                    carte2.image = null;\r\n                    carte2.name = null;\r\n\r\n                  } else\r\n                    pvAnonymous = 1;\r\n\r\n                  //Termine la fonction une fois qu'une carte a été détruite\r\n                  break outerLoop;\r\n                }\r\n              }\r\n            }\r\n        if (!carteDefendu) {\r\n          console.log(\"carte pas defendue\")\r\n          this.perdrePvAttaquant();\r\n          cartesAttaque.push(card);\r\n        }\r\n      } else if (!carteTrouvee) {\r\n        alert(\"Carte pas présente\")\r\n      }else if (carteDejaAttaquer) {\r\n        cartesAttaque.push(card);\r\n        alert(\"cette carte a deja attaquer\")\r\n      } else if (cartePresenteDepuis.poseeDepuis !== 2 ){\r\n        cartesAttaque.push(card);\r\n        alert(\"Vous devez attendre un tour avant de pouvoir attaquer avec cette carte !\")\r\n      }\r\n      if (card.name === \"Anonymous\" && pvAnonymous > 0 && nbrAttaqueAnonymous < 2){\r\n        card.poseeDepuis = 2;\r\n        cartesAttaque.push(card);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Retire toutes les cartes en défense lors de l'arrivée de l'anonymous\r\n     * @param card carte scannée\r\n     * @param reader liste des cases\r\n     */\r\n    arriveeAnonymous(card, reader) {\r\n      pvAnonymous = 2;\r\n      //Vérifie si la carte est bel et bien l'anonymous et qu'elle n'a pas déjà été posée\r\n      if (card.name === \"Anonymous\" && !dejaPosee) {\r\n        dejaPosee = true;\r\n        //Vide les cases\r\n        reader[0].name = null;\r\n        reader[0].image = null;\r\n        reader[1].name = null;\r\n        reader[1].image = null;\r\n        reader[4].name = null;\r\n        reader[4].image = null;\r\n\r\n        //Vide la liste des cartes en jeu, car plus aucune n'est présente\r\n        carteEnJeu = [];\r\n      }\r\n    },\r\n    defendMalin(cartesEnMains, reader) {\r\n      nbrAttaqueAnonymous = 0;\r\n      let test = [];\r\n      for (let a = 0; a < cartesAttaque.length; a++)\r\n        test.push(cartesAttaque[a]);\r\n      console.log(\"Test \", test)\r\n\r\n      //Pose une carte seulement s'il n'y en a pas une de déjà posé\r\n      if (reader.image === null) {\r\n        let index = 0;\r\n        let cartePosee = null;\r\n        console.log(\"Cartes en main\", cartesEnMains)\r\n        console.log(\"Cartes en jeu\", carteEnJeu)\r\n        //Empêche la redondance de données d'être la première carte posée sur le terrain\r\n        // afin qu'elle puisse copier une carte déjà présente\r\n\r\n        outerLoop:\r\n            for (let i = 0; i < test.length; i++) {\r\n              for (let j = 0; j < cartesEnMains.length; j++) {\r\n                console.log(\"Je loupe ?\", j)\r\n                if (cartesEnMains[j].name === \"Stockage\") {\r\n                  this.$refs.Case_4_Defenseur_Attaque.triggerLockAnimation();\r\n                  cartePosee = cartesEnMains[j];\r\n                  // this.ouvrirCadenas();\r\n                  alert(\"Cadenas\");\r\n                } else {\r\n                  console.log(\"Ici ca passe\")\r\n                  let carteEnMainCounter = cartesEnMains[j].counter;\r\n                  //console.log(\"les counter\", carteEnMainCounter)\r\n                  if (carteEnMainCounter.includes(test[i].name)) {\r\n                    console.log(\"Ici aussi\")\r\n                    cartePosee = cartesEnMains[j];\r\n                    if (cartePosee.name === \"Redondance de données\") {\r\n                      console.log(\"La aussi\");\r\n                      if (carteEnJeu.length === 0) {\r\n                        console.log(\"La pareil\")\r\n                        cartePosee = cartesEnMains[j + 1];\r\n                      }\r\n                      else {\r\n                        cartePosee = carteEnJeu[0];\r\n                        console.log(\"Ou est le probleme\")\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n\r\n                console.log(\"Defend malin\")\r\n                reader.image = cartePosee.image;\r\n                reader.name = cartePosee.name;\r\n                cartesEnMains.splice(j, 1);\r\n                carteEnJeu.push(cartePosee);\r\n                test = [];\r\n                break outerLoop;\r\n              }\r\n            }\r\n        if (cartePosee === null) {\r\n          do {\r\n            index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\r\n            cartePosee = cartesEnMains[index];\r\n          } while (cartePosee.name === \"Redondance de données\" && carteEnJeu.length === 0);\r\n\r\n          //La carte redondance de données devient une copie de la carte sur la case de gauche.\r\n          if (cartePosee.name === \"Redondance de données\") {\r\n            alert(\"Redondance de données\");\r\n            cartePosee = carteEnJeu[0];\r\n          }\r\n          reader.image = cartePosee.image;\r\n          reader.name = cartePosee.name;\r\n          cartesEnMains.splice(index, 1);\r\n\r\n          carteEnJeu.push(cartePosee);\r\n        }\r\n      }\r\n    },\r\n    // Gère la perte de PV de l'attaquant\r\n    perdrePvAttaquant() {\r\n      if (pv.value > 0) {\r\n        pv.value--;  // Décrémentation de la valeur réactive de pv\r\n        console.log(\"pv\", pv.value);\r\n      }\r\n    },\r\n    resetDejaAttaquer(){\r\n      dejaAttaquer = [];\r\n    },\r\n    trouverObjet(card, liste){\r\n      return liste.find(objet => objet.name === card.name);\r\n    },\r\n\r\n    trouverCarte(){\r\n      return true;\r\n    }\r\n  }\r\n};\r\n</script>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}