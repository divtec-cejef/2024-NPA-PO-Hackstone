{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Importation du fichier JSON des CARTES\n//let cardsData = [];\n\nconst cardsData = require('../../../cards.json');\nconst DECK = {\n  cardsData\n};\nconst CARTES = DECK.cardsData.cards;\nexport default {\n  methods: {\n    /**\r\n     * Génère le deck du défenseur à partir d'un fichier json\r\n     * @returns cartesAttaque cartes présentent dans le deck\r\n     */\n    genererDeckAttaque() {\n      let cartesAttaque = [];\n      for (let i = 0; i < CARTES.length; i++) {\n        if (CARTES[i].type === 'attaque') {\n          //Retrouve le nombre de fois qu'une carte est présente dans le deck grâce à son nombre d'ID\n          for (let j = 0; j < CARTES[i].uid.length; j++) cartesAttaque.push(CARTES[i]);\n        }\n      }\n      return cartesAttaque;\n    },\n    /**\r\n     * Génération d'un nombre entier  aléatoire\r\n     * @param min fourchette minimale\r\n     * @param max fourchette maximale\r\n     * @returns {*} nombre entier aléatoire\r\n     */\n    getNombreAleatoire(min, max) {\n      return Math.floor(Math.random() * (max - min + 1)) + min;\n    },\n    /**\r\n     * Pioche 5 cartes au hasard, si l'ordinateur possède déjà 5 cartes dans sa main, en pioche une seule,\r\n     * ensuite retire les cartes piochées du deck\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMain cartes présentent dans la main de l'ordinateur\r\n     */\n    piocher(cartesDeck, cartesEnMain) {\n      if (cartesEnMain.length >= 5) {\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\n        cartesEnMain.push(cartesDeck[index]);\n        cartesDeck.splice(index, 1);\n      }\n      while (cartesEnMain.length < 5) {\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\n        cartesEnMain.push(cartesDeck[index]);\n        cartesDeck.splice(index, 1);\n      }\n      cartesEnMain.splice(cartesEnMain.length, 1);\n    },\n    /**\r\n     * Effectue toutes les actions nécessaires au début de n'importe quel tour (excepté le premier)\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMains cartes présentent dans la main de l'ordinateur\r\n     */\n    DebutTour(cartesDeck, cartesEnMains) {\n      this.piocher(cartesDeck, cartesEnMains);\n    },\n    /**\r\n     * Pose une carte aléatoire présente dans la main sur la case saisie, si la case est vide\r\n     * @param cartesEnMains cartes présentent dans la main\r\n     * @param reader case sur laquelle la carte va être affichée\r\n     */\n    poserCarte(cartesEnMains, reader) {\n      if (reader.image === null) {\n        let index = 0;\n        let cartePosee;\n        index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\n        cartePosee = cartesEnMains[index];\n        reader.image = cartePosee.image;\n        cartesEnMains.splice(index, 1);\n        console.log(cartePosee);\n      }\n    },\n    /**\r\n     * Retire une carte d'une case\r\n     * @param reader case sur laquelle l'image va être retirée\r\n     */\n    retirerCarte(reader) {\n      reader.image = null;\n    }\n  }\n};","map":{"version":3,"names":["cardsData","require","DECK","CARTES","cards","methods","genererDeckAttaque","cartesAttaque","i","length","type","j","uid","push","getNombreAleatoire","min","max","Math","floor","random","piocher","cartesDeck","cartesEnMain","index","splice","DebutTour","cartesEnMains","poserCarte","reader","image","cartePosee","console","log","retirerCarte"],"sources":["C:\\Users\\courluc\\IdeaProjects\\2024-NPA-PO-Hackstone\\src\\components\\plateauDefense\\fonctionnaliteDefense.vue"],"sourcesContent":["<script>\r\n// Importation du fichier JSON des CARTES\r\n//let cardsData = [];\r\n\r\nconst cardsData = require('../../../cards.json');\r\nconst DECK = {\r\n  cardsData\r\n};\r\nconst CARTES = DECK.cardsData.cards;\r\nexport default {\r\n  methods: {\r\n\r\n    /**\r\n     * Génère le deck du défenseur à partir d'un fichier json\r\n     * @returns cartesAttaque cartes présentent dans le deck\r\n     */\r\n    genererDeckAttaque() {\r\n      let cartesAttaque = [];\r\n      for (let i = 0; i < CARTES.length; i++) {\r\n        if (CARTES[i].type === 'attaque') {\r\n          //Retrouve le nombre de fois qu'une carte est présente dans le deck grâce à son nombre d'ID\r\n          for (let j = 0; j < CARTES[i].uid.length; j++)\r\n            cartesAttaque.push(CARTES[i]);\r\n        }\r\n      }\r\n      return cartesAttaque;\r\n    },\r\n\r\n    /**\r\n     * Génération d'un nombre entier  aléatoire\r\n     * @param min fourchette minimale\r\n     * @param max fourchette maximale\r\n     * @returns {*} nombre entier aléatoire\r\n     */\r\n    getNombreAleatoire(min, max) {\r\n      return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    },\r\n\r\n    /**\r\n     * Pioche 5 cartes au hasard, si l'ordinateur possède déjà 5 cartes dans sa main, en pioche une seule,\r\n     * ensuite retire les cartes piochées du deck\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMain cartes présentent dans la main de l'ordinateur\r\n     */\r\n    piocher(cartesDeck, cartesEnMain) {\r\n      if (cartesEnMain.length >= 5) {\r\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\r\n        cartesEnMain.push(cartesDeck[index]);\r\n        cartesDeck.splice(index, 1);\r\n      }\r\n      while (cartesEnMain.length < 5) {\r\n        let index = this.getNombreAleatoire(0, cartesDeck.length - 1);\r\n        cartesEnMain.push(cartesDeck[index]);\r\n        cartesDeck.splice(index, 1);\r\n      }\r\n      cartesEnMain.splice(cartesEnMain.length, 1);\r\n\r\n    },\r\n\r\n    /**\r\n     * Effectue toutes les actions nécessaires au début de n'importe quel tour (excepté le premier)\r\n     * @param cartesDeck cartes présentent dans le deck\r\n     * @param cartesEnMains cartes présentent dans la main de l'ordinateur\r\n     */\r\n    DebutTour(cartesDeck, cartesEnMains) {\r\n      this.piocher(cartesDeck, cartesEnMains);\r\n    },\r\n\r\n    /**\r\n     * Pose une carte aléatoire présente dans la main sur la case saisie, si la case est vide\r\n     * @param cartesEnMains cartes présentent dans la main\r\n     * @param reader case sur laquelle la carte va être affichée\r\n     */\r\n    poserCarte(cartesEnMains, reader) {\r\n      if (reader.image === null) {\r\n        let index = 0;\r\n        let cartePosee;\r\n        index = this.getNombreAleatoire(0, cartesEnMains.length - 1);\r\n        cartePosee = cartesEnMains[index];\r\n        reader.image = cartePosee.image;\r\n        cartesEnMains.splice(index, 1);\r\n        console.log(cartePosee);\r\n      }\r\n    },\r\n    /**\r\n     * Retire une carte d'une case\r\n     * @param reader case sur laquelle l'image va être retirée\r\n     */\r\n    retirerCarte(reader){\r\n      reader.image = null;\r\n    }\r\n  }\r\n};\r\n</script>\r\n"],"mappings":";AACA;AACA;;AAEA,MAAMA,SAAQ,GAAIC,OAAO,CAAC,qBAAqB,CAAC;AAChD,MAAMC,IAAG,GAAI;EACXF;AACF,CAAC;AACD,MAAMG,MAAK,GAAID,IAAI,CAACF,SAAS,CAACI,KAAK;AACnC,eAAe;EACbC,OAAO,EAAE;IAEP;;;;IAIAC,kBAAkBA,CAAA,EAAG;MACnB,IAAIC,aAAY,GAAI,EAAE;MACtB,KAAK,IAAIC,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAIL,MAAM,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;QACtC,IAAIL,MAAM,CAACK,CAAC,CAAC,CAACE,IAAG,KAAM,SAAS,EAAE;UAChC;UACA,KAAK,IAAIC,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAIR,MAAM,CAACK,CAAC,CAAC,CAACI,GAAG,CAACH,MAAM,EAAEE,CAAC,EAAE,EAC3CJ,aAAa,CAACM,IAAI,CAACV,MAAM,CAACK,CAAC,CAAC,CAAC;QACjC;MACF;MACA,OAAOD,aAAa;IACtB,CAAC;IAED;;;;;;IAMAO,kBAAkBA,CAACC,GAAG,EAAEC,GAAG,EAAE;MAC3B,OAAOC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,KAAKH,GAAE,GAAID,GAAE,GAAI,CAAC,CAAC,IAAIA,GAAG;IAC1D,CAAC;IAED;;;;;;IAMAK,OAAOA,CAACC,UAAU,EAAEC,YAAY,EAAE;MAChC,IAAIA,YAAY,CAACb,MAAK,IAAK,CAAC,EAAE;QAC5B,IAAIc,KAAI,GAAI,IAAI,CAACT,kBAAkB,CAAC,CAAC,EAAEO,UAAU,CAACZ,MAAK,GAAI,CAAC,CAAC;QAC7Da,YAAY,CAACT,IAAI,CAACQ,UAAU,CAACE,KAAK,CAAC,CAAC;QACpCF,UAAU,CAACG,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;MAC7B;MACA,OAAOD,YAAY,CAACb,MAAK,GAAI,CAAC,EAAE;QAC9B,IAAIc,KAAI,GAAI,IAAI,CAACT,kBAAkB,CAAC,CAAC,EAAEO,UAAU,CAACZ,MAAK,GAAI,CAAC,CAAC;QAC7Da,YAAY,CAACT,IAAI,CAACQ,UAAU,CAACE,KAAK,CAAC,CAAC;QACpCF,UAAU,CAACG,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;MAC7B;MACAD,YAAY,CAACE,MAAM,CAACF,YAAY,CAACb,MAAM,EAAE,CAAC,CAAC;IAE7C,CAAC;IAED;;;;;IAKAgB,SAASA,CAACJ,UAAU,EAAEK,aAAa,EAAE;MACnC,IAAI,CAACN,OAAO,CAACC,UAAU,EAAEK,aAAa,CAAC;IACzC,CAAC;IAED;;;;;IAKAC,UAAUA,CAACD,aAAa,EAAEE,MAAM,EAAE;MAChC,IAAIA,MAAM,CAACC,KAAI,KAAM,IAAI,EAAE;QACzB,IAAIN,KAAI,GAAI,CAAC;QACb,IAAIO,UAAU;QACdP,KAAI,GAAI,IAAI,CAACT,kBAAkB,CAAC,CAAC,EAAEY,aAAa,CAACjB,MAAK,GAAI,CAAC,CAAC;QAC5DqB,UAAS,GAAIJ,aAAa,CAACH,KAAK,CAAC;QACjCK,MAAM,CAACC,KAAI,GAAIC,UAAU,CAACD,KAAK;QAC/BH,aAAa,CAACF,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;QAC9BQ,OAAO,CAACC,GAAG,CAACF,UAAU,CAAC;MACzB;IACF,CAAC;IACD;;;;IAIAG,YAAYA,CAACL,MAAM,EAAC;MAClBA,MAAM,CAACC,KAAI,GAAI,IAAI;IACrB;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}